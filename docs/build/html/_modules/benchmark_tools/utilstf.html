<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>Benchmarks of Multicomponent Signal Methods :: benchmark_tools.utilstf</title>
  

  <link rel="icon" type="image/png" sizes="32x32" href="../../_static/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../_static/img/favicon-16x16.png">
  <link rel="index" title="Index" href="../../genindex.html"/>

  <link rel="stylesheet" href="../../_static/css/insegel.css"/>
  <link rel="stylesheet" href="../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/sphinx_highlight.js"></script>
      <script type="text/javascript" src="../../_static/clipboard.min.js"></script>
      <script type="text/javascript" src="../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="insegel-container">
    <header>
      <div id="logo-container">
          
          <h1>Benchmarks of Multicomponent Signal Methods</h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>
    </header>

    <div id="content-container">

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for benchmark_tools.utilstf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This file contains a number of utilities for time-frequency analysis. </span>
<span class="sd">Some functions has been modified from the supplementary code of:</span>
<span class="sd">Bardenet, R., Flamant, J., &amp; Chainais, P. (2020). &quot;On the zeros of the spectrogram of </span>
<span class="sd">white noise.&quot; Applied and Computational Harmonic Analysis, 48(2), 682-705.</span>

<span class="sd">Those functions are:</span>
<span class="sd">- getSpectrogram(signal)</span>
<span class="sd">- findCenterEmptyBalls(Sww, pos_exp, radi_seg=1)</span>
<span class="sd">- getConvexHull(Sww, pos_exp, empty_mask, radi_expand=0.5)</span>
<span class="sd">- reconstructionSignal(hull_d, stft)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">complex128</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">pi</span> <span class="k">as</span> <span class="n">pi</span>
<div class="viewcode-block" id="get_gauss_window"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.get_gauss_window">[docs]</a><span class="k">def</span> <span class="nf">get_gauss_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">prec</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
    <span class="n">l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">Nfft</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">tmt0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">t0</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">tmt0</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>    
    <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="get_round_window"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.get_round_window">[docs]</a><span class="k">def</span> <span class="nf">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Generates a round Gaussian window, i.e. same essential support in time and </span>
<span class="sd">    frequency: g(n) = exp(-pi*(n/T)^2) for computing the Short-Time Fourier Transform.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        Nfft: Number of samples of the desired fft.</span>

<span class="sd">    Returns:</span>
<span class="sd">        g (ndarray): A round Gaussian window.</span>
<span class="sd">        T (float): The scale of the Gaussian window (T = sqrt(Nfft))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># analysis window</span>
    <span class="n">L</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>
    <span class="n">l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">Nfft</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
 
    <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">tmt0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">t0</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">tmt0</span><span class="o">/</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span>    
    <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">L</span></div>

<div class="viewcode-block" id="get_stft"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.get_stft">[docs]</a><span class="k">def</span> <span class="nf">get_stft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">xrow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">xrow</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">xrow</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="n">tcol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">hlength</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">Nfft</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">hlength</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">hlength</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">hlength</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">hrow</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">hrow</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">Lh</span><span class="o">=</span><span class="p">(</span><span class="n">hrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">tfr</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nfft</span><span class="p">,</span><span class="n">tcol</span><span class="p">))</span>   
    <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tcol</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">icol</span><span class="p">];</span> 
        <span class="n">tau</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Nfft</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">Lh</span><span class="p">,</span><span class="n">ti</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Nfft</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="n">Lh</span><span class="p">,</span><span class="n">xrow</span><span class="o">-</span><span class="n">ti</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">Nfft</span><span class="o">+</span><span class="n">tau</span><span class="p">,</span><span class="n">Nfft</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">);</span> 
        <span class="n">tfr</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span><span class="n">icol</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">ti</span><span class="o">+</span><span class="n">tau</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">tau</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">tau</span><span class="p">])</span>
    
    <span class="n">tfr</span><span class="o">=</span><span class="n">fft</span><span class="p">(</span><span class="n">tfr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">tfr</span></div>

<div class="viewcode-block" id="get_istft"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.get_istft">[docs]</a><span class="k">def</span> <span class="nf">get_istft</span><span class="p">(</span><span class="n">tfr</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="n">N</span><span class="p">,</span><span class="n">NbPoints</span> <span class="o">=</span> <span class="n">tfr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tcol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">hrow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> 
    <span class="n">Lh</span><span class="o">=</span><span class="p">(</span><span class="n">hrow</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    <span class="n">tfr</span><span class="o">=</span><span class="n">ifft</span><span class="p">(</span><span class="n">tfr</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tcol</span><span class="p">,))</span>
    <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tcol</span><span class="p">):</span>
        <span class="n">valuestj</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="n">icol</span><span class="o">-</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">icol</span><span class="o">-</span><span class="n">Lh</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">tcol</span><span class="p">,</span><span class="n">icol</span><span class="o">+</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">icol</span><span class="o">+</span><span class="n">Lh</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tj</span> <span class="ow">in</span> <span class="n">valuestj</span><span class="p">:</span>
            <span class="n">tau</span><span class="o">=</span><span class="n">icol</span><span class="o">-</span><span class="n">tj</span> 
            <span class="n">indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">tau</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">+</span><span class="n">tfr</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span><span class="n">tj</span><span class="p">]</span><span class="o">*</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">tau</span><span class="p">]</span>
        
        <span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">icol</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">Lh</span><span class="o">+</span><span class="n">icol</span><span class="o">-</span><span class="n">valuestj</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<span class="c1"># def get_stft(signal, window = None, overlap = None):</span>
<span class="c1">#     &quot;&quot;&quot; Compute the STFT of the signal. Signal is padded with zeros.</span>
<span class="c1">#     The outputs corresponds to the STFT with the regular size and also the</span>
<span class="c1">#     zero padded version. The signal is zero padded to alleviate border effects.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         signal (ndarray): The signal to analyse.</span>
<span class="c1">#         window (ndarray, optional): The window to use. If None, uses a rounded Gaussian</span>
<span class="c1">#         window. Defaults to None.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         stft(ndarray): Returns de stft of the signal.</span>
<span class="c1">#         stft_padded(ndarray): Returns the stft of the zero-padded signal.</span>
<span class="c1">#         Npad(int): Number of zeros padded on each side of the signal.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
    
<span class="c1">#     N = np.max(signal.shape)</span>
<span class="c1">#     if window is None:</span>
<span class="c1">#         window, _ = get_round_window(N)</span>

<span class="c1">#     Npad = N//2 #0 #int(np.sqrt(N))</span>
<span class="c1">#     Nfft = len(window)</span>
    
<span class="c1">#     if overlap is None:</span>
<span class="c1">#         overlap = Nfft-1</span>
    
<span class="c1">#     if signal.dtype == complex128:</span>
<span class="c1">#         signal_pad = np.zeros(N+2*Npad, dtype=complex128)</span>
<span class="c1">#     else:</span>
<span class="c1">#         signal_pad = np.zeros(N+2*Npad)</span>

<span class="c1">#     # signal_pad = np.zeros(N+2*Npad)</span>
<span class="c1">#     signal_pad[Npad:Npad+N] = signal</span>

<span class="c1">#     # computing STFT</span>
<span class="c1">#     _, _, stft_padded = sg.stft(signal_pad, window=window, nperseg=Nfft, noverlap = overlap)</span>
    
<span class="c1">#     # if signal.dtype == complex128:</span>
<span class="c1">#     #     stft_padded = stft_padded[0:Nfft//2+1,:]</span>
        
<span class="c1">#     stft = stft_padded[:,Npad:Npad+N]</span>
<span class="c1">#     return stft, stft_padded, Npad</span>


<div class="viewcode-block" id="get_spectrogram"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.get_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">get_spectrogram</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the round spectrogram of the signal computed with a given window. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal(ndarray): A vector with the signal to analyse.</span>

<span class="sd">    Returns:</span>
<span class="sd">        S(ndarray): Spectrogram of the signal.</span>
<span class="sd">        stft: Short-time Fourier transform of the signal.</span>
<span class="sd">        stft_padded: Short-time Fourier transform of the padded signal.</span>
<span class="sd">        Npad: Number of zeros added in the zero-padding process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_round_window</span><span class="p">(</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
        
    <span class="n">stft</span><span class="o">=</span><span class="n">get_stft</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">onesided</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nfft</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stft</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>                
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">stft</span></div>


<div class="viewcode-block" id="find_zeros_of_spectrogram"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.find_zeros_of_spectrogram">[docs]</a><span class="k">def</span> <span class="nf">find_zeros_of_spectrogram</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="n">aux_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span>
    <span class="n">aux_S</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">aux_S</span>
    <span class="n">aux_ceros</span> <span class="o">=</span> <span class="p">((</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span> 
            <span class="p">)</span>
    <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_ceros</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># Position of zeros in norm. coords.</span>
    <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">pos</span></div>


<div class="viewcode-block" id="reconstruct_signal"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.reconstruct_signal">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal</span><span class="p">(</span><span class="n">hull_d</span><span class="p">,</span> <span class="n">stft</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruction using the convex hull.</span>
<span class="sd">    This function is deprecated and conserved for retrocompatibility purposes only.</span>

<span class="sd">    Args:</span>
<span class="sd">        hull_d (_type_): _description_</span>
<span class="sd">        stft (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Nfft</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))</span>
    <span class="n">tmax</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tmin</span>
    <span class="n">fmin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))</span>
    <span class="n">fmax</span> <span class="o">=</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">fmin</span>

    <span class="c1"># sub mask : check which points are in the convex hull</span>
    <span class="n">vecx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))))</span>
    <span class="n">vecy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Nfft</span><span class="p">))))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">vecx</span><span class="p">,</span> <span class="n">vecy</span><span class="p">))</span>
    <span class="n">sub_mask</span> <span class="o">=</span> <span class="n">hull_d</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">0</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">fmin</span><span class="p">:</span><span class="n">fmax</span><span class="p">,</span> <span class="n">tmin</span><span class="p">:</span><span class="n">tmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_mask</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mascara:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="c1"># create a mask</span>
    <span class="c1">#mask = np.zeros(stft.shape, dtype=bool)</span>
    <span class="c1">#mask[fmin:fmax, base+tmin:base+tmax] = sub_mask</span>

    <span class="c1"># reconstruction</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">/</span><span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># t, xorigin = sg.istft(stft, window=g,  nperseg=Nfft, noverlap=Nfft-1)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">mask</span><span class="o">*</span><span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>  <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">t</span> </div>



<div class="viewcode-block" id="reconstruct_signal_2"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.reconstruct_signal_2">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal_2</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">Npad</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruction using a mask given as parameter</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (_type_): _description_</span>
<span class="sd">        stft (_type_): _description_</span>
<span class="sd">        Npad (_type_): _description_</span>
<span class="sd">        Nfft (_type_, optional): _description_. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Ni</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">Nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nfft</span> <span class="o">=</span> <span class="n">Ni</span>
    
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Nfft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span><span class="o">/</span><span class="n">window</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    
    <span class="n">Nfft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlap</span><span class="o">=</span><span class="n">Nfft</span><span class="o">-</span><span class="mi">1</span>


    <span class="c1"># reconstruction        </span>
    <span class="n">mask_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">mask_aux</span><span class="p">[:,</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">Ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="c1"># t, xorigin = sg.istft(stft, window=g,  nperseg=Nfft, noverlap=Nfft-1)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span><span class="n">mask_aux</span><span class="o">*</span><span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">noverlap</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">)</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="n">Npad</span><span class="p">:</span><span class="n">Npad</span><span class="o">+</span><span class="n">Ni</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">xr</span><span class="p">,</span> <span class="n">t</span></div>

<div class="viewcode-block" id="reconstruct_signal_3"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.reconstruct_signal_3">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_signal_3</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">stft</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mask_complete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">stft</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask_complete</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="n">mask_complete</span><span class="p">[</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]::,:]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">get_istft</span><span class="p">(</span><span class="n">stft</span><span class="o">*</span><span class="n">mask_complete</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">stft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">xr</span></div>


<span class="c1"># def find_zeros_of_spectrogram(M,th=1e-14):</span>
<span class="c1">#     &quot;&quot;&quot; Finds the local minima of the spectrogram matrix M.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         M (_type_): Matrix with real values.</span>
<span class="c1">#         th (_type_): A given threshold.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         _type_: _description_</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     C,R = M.shape</span>
<span class="c1">#     Mid_Mid = np.zeros((C,R), dtype=bool)</span>
<span class="c1">#     for c in range(1, C-1):</span>
<span class="c1">#         for r in range(1, R-1):</span>
<span class="c1">#             T = M[c-1:c+2,r-1:r+2]</span>
<span class="c1">#             Mid_Mid[c, r] = (np.min(T) == T[1, 1]) * (np.min(T) &gt; th)</span>
<span class="c1">#             #Mid_Mid[c, r] = (np.min(T) == T[1, 1])</span>
<span class="c1">#     x, y = np.where(Mid_Mid)</span>
<span class="c1">#     pos = np.zeros((len(x), 2)) # Position of zeros in norm. coords.</span>
<span class="c1">#     pos[:, 0] = x</span>
<span class="c1">#     pos[:, 1] = y</span>
<span class="c1">#     return pos</span>


<div class="viewcode-block" id="snr_comparison"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.snr_comparison">[docs]</a><span class="k">def</span> <span class="nf">snr_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x_hat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>
<span class="sd">        x (_type_): _description_</span>
<span class="sd">        x_hat (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">qrf</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x_hat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qrf</span></div>


<div class="viewcode-block" id="add_snr_block"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.add_snr_block">[docs]</a><span class="k">def</span> <span class="nf">add_snr_block</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">snr</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds noise to a signal x with SNR equal to snr.</span>
<span class="sd">    SNR is defined as SNR (dB) = 10 * log10(Ex/En), where Ex and En are the energy of </span>
<span class="sd">    the signal and the noise, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): Signal.</span>
<span class="sd">        snr (_type_): Signal-to-Noise Ratio in dB.</span>
<span class="sd">        K (int, optional): The number of noisy signals generated, vertically stacked. </span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Block of shape [K,N], where K is the number of noisy signals, and N is </span>
<span class="sd">        length of the signal x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># print(x)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">)</span>
    <span class="c1"># n = n - np.mean(n,axis = 0)</span>
    <span class="c1"># print(np.mean(n, axis = 0))</span>
    <span class="c1"># x = x+n</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(np.sum(n[:,0]**2))</span>

    <span class="n">Pn</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="n">snr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="n">snr_out1</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Px</span> <span class="o">/</span> <span class="n">Pn</span><span class="p">)</span>
    <span class="c1"># print(snr_out)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">T</span></div>
    

<div class="viewcode-block" id="add_snr"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.add_snr">[docs]</a><span class="k">def</span> <span class="nf">add_snr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">snr</span><span class="p">,</span><span class="n">complex_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds noise to a signal x with SNR equal to snr. SNR is defined as </span>
<span class="sd">    SNR (dB) = 10 * log10(Ex/En), where Ex and En are the energy of the signal and the </span>
<span class="sd">    noise, respectively.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (ndarray): Signal.</span>
<span class="sd">        snr (_type_): Signal-to-Noise Ratio in dB.</span>
<span class="sd">        K (int, optional): The number of noisy signals generated, vertically stacked. </span>
<span class="sd">        Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Block of shape [K,N], where K is the number of noisy signals, and N is </span>
<span class="sd">        length of the signal x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Create the noise for signal with given SNR:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">complex_noise</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,)</span>
        
    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Normalize to 1 the variance of noise.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>
    <span class="n">Pn</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="n">snr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># Give noise the prescribed variance.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Pn</span><span class="p">)</span>

    <span class="c1"># Pn = Px * 10 ** (- snr / 10)</span>
    <span class="c1"># n = n * np.sqrt(Pn)</span>
    <span class="c1"># snr_out1 = 20 * np.log10(np.sqrt(np.sum(x**2))/np.sqrt(np.sum(n**2)))</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Px</span> <span class="o">/</span> <span class="n">Pn</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;snr_out:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">snr_out</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="n">n</span></div>


<div class="viewcode-block" id="hermite_poly"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.hermite_poly">[docs]</a><span class="k">def</span> <span class="nf">hermite_poly</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">return_all</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a Hermite polynomial of order n on the vector t.</span>

<span class="sd">    Args:</span>
<span class="sd">        t (ndarray, float): A real valued vector on which compute the Hermite </span>
<span class="sd">        polynomials.</span>
<span class="sd">        n (int): Order of the Hermite polynomial.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Returns an array with the Hermite polynomial computed on t.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),))</span>
        <span class="n">all_hp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span>

    <span class="k">else</span><span class="p">:</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span>
            <span class="n">all_hp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),))</span>
            <span class="n">all_hp</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="c1"># if n &gt;= 1:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># hp = 2*t*hermite_poly(t,n-1) - 2*(n-1)*hermite_poly(t,n-2)</span>
                <span class="n">hp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">hp</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hp</span><span class="p">,</span> <span class="n">all_hp</span></div>


<div class="viewcode-block" id="hermite_fun"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.hermite_fun">[docs]</a><span class="k">def</span> <span class="nf">hermite_fun</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_all</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes an Hermite function of order q, that consist in a centered Hermite </span>
<span class="sd">    polynomial multiplied by the squared-root of a centered Gaussian given by: </span>
<span class="sd">    exp(-pi(t/T)^2). The parameter T fixes the width of the Gaussian function.</span>

<span class="sd">    Args:</span>
<span class="sd">        N (int): Length of the function in samples</span>
<span class="sd">        q (int): Order of the Hermite polynomial.</span>
<span class="sd">        t (ndarray): Values on which compute the function. If None, uses a centered </span>
<span class="sd">        vector from -N//2 to N//2-1. Defaults to None.</span>
<span class="sd">        T (float): Scale of the Gaussian involved in the Hermite function. If None,</span>
<span class="sd">        N = sqrt(N). Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">all_hp</span> <span class="o">=</span> <span class="n">hermite_poly</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gaussian_basic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">hfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">Cnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)))</span>
        <span class="c1"># gaussian_basic /= np.sum(gaussian_basic)</span>
        <span class="n">hfunc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gaussian_basic</span><span class="o">*</span><span class="n">all_hp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">Cnorm</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hfunc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hfunc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hfunc</span></div>
        
<div class="viewcode-block" id="sigmerge"><a class="viewcode-back" href="../../benchmark_tools.html#benchmark_tools.utilstf.sigmerge">[docs]</a><span class="k">def</span> <span class="nf">sigmerge</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">return_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Get signal parameters.</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
    <span class="n">ex1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ex2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">h</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ex1</span><span class="o">/</span><span class="p">(</span><span class="n">ex2</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">ratio</span><span class="o">/</span><span class="mi">10</span><span class="p">)))</span>
    <span class="n">scaled_noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">*</span><span class="n">h</span>
    <span class="n">sig</span><span class="o">=</span><span class="n">x1</span><span class="o">+</span><span class="n">scaled_noise</span>

    <span class="k">if</span> <span class="n">return_noise</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sig</span><span class="p">,</span> <span class="n">scaled_noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sig</span></div>
</pre></div>

        </div>
      </div>

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
            <input type="text" name="q" placeholder="Search..." />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">

          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme_link.html">Benchmarks of Multi-Component Signal Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#public-benchmarks">Public Benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#benchmarking-a-new-method">Benchmarking a new method</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#installation-using-poetry">Installation using <code class="docutils literal notranslate"><span class="pre">poetry</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#adding-a-new-method-to-benchmark">Adding a new method to benchmark</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../readme_link.html#python-based-methods">Python-based methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../readme_link.html#matlab-based-methods">Matlab-based methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#running-the-benchmark-with-new-methods">Running the benchmark with new methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#changing-the-benchmark-configuration">Changing the benchmark configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#adding-dependencies">Adding dependencies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../readme_link.html#modify-matlabengine-module-version">Modify <code class="docutils literal notranslate"><span class="pre">matlabengine</span></code> module version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../readme_link.html#size-of-outputs-according-to-the-task">Size of outputs according to the task</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Packages:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../benchmark_tools.html">benchmark_tools package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../methods.html">methods package</a></li>
</ul>

  


        </div>

        

      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            

            
        </ul>

        
            <div id="copyright">
                &copy; 2023, Juan Manuel Miramont-Taurel
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/Autophagy/insegel">Insegel</a>

        </div>
    </div>

    <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

    <script type="text/javascript">
      $("#menu-toggle").click(function() {
        $("#menu-toggle").toggleClass("toggled");
        $("#side-menu-container").slideToggle(300);
      });
    </script>

</footer> 

</div>

</body>
</html>